# 07 Caching

App Router のキャッシュに関するドキュメントと図解

## 1. イントロダクション

なぜ Next.js のキャッシングについて理解することが重要なのでしょうか？
それは単純に、適切なキャッシング戦略を実装することで以下を実現できるからです。

- ウェブサイトのパフォーマンスが劇的に向上する
- サーバーへの負荷を減らしてコストを削減できる
- ユーザー体験を向上させることができる

App Router のキャッシングは大きく分けて4つのレイヤーがあります。

- Request Memoization（リクエストメモ化）
- Data Cache（データキャッシュ）
- Full Route Cache（フルルートキャッシュ）
- Router Cache（ルーターキャッシュ）

## 2. キャッシングの基本概念

まず、Next.js におけるキャッシングとは何かについて基本から説明します。
キャッシングとは、一度取得したデータや生成したコンテンツを一時的に保存しておき、同じリクエストがあった場合に再計算や再取得せずに保存したものを返す仕組みです。これにより：

- データベースへのクエリ回数が減少
- API呼び出しが減り
  レンダリング処理が省略され
  結果として応答時間が短縮されます

Pages Router と App Router では根本的なアーキテクチャが異なります。

### Pages Router のキャッシング

- getStaticProps による Static Generation
- getServerSideProps によるServer-side Rendering
- Incremental Static Regeneration (ISR)

これらは比較的シンプルで理解しやすい仕組みでした。
ページ単位でキャッシング戦略を決定し、\_app.js や \_document.js で共通の設定を行うことができました。

### App Router のキャッシング

- React Server Components をベースにした新しいアーキテクチャ
- コンポーネントレベルでのきめ細かいキャッシング制御
- ルートセグメントごとに異なるキャッシング戦略を適用可能
- 複数のキャッシングレイヤーによる階層的な仕組み

App Router のアプローチは柔軟性が高く、パフォーマンスの最適化においてより多くの可能性を提供します。しかし、その複雑さから初めは混乱することも多いでしょう。
パフォーマンスへの影響としては、適切にキャッシングを設定することで：

初回読み込み時間（TTFB: Time to First Byte）の短縮
サーバーリソースの効率的な利用
より良いユーザー体験
高トラフィック時の安定性向上

といった大きなメリットがあります。
それでは、App Router の各キャッシングレイヤーについて詳しく見ていきましょう。

## 3. App Routerにおけるキャッシングレイヤー

App Router では、4つの主要なキャッシングレイヤーが互いに連携しています。それぞれのレイヤーは異なる目的と動作を持っており、全体として効率的なキャッシングシステムを構成しています。

### Request Memoization（リクエストメモ化）

Request Memoization は、単一のレンダリングパス内で同じリクエストが複数回行われた場合に、最初の結果を再利用する仕組みです。

- React のレンダリングサイクル内でのみ有効
- サーバーのメモリ内で一時的に保持される
- 同一リクエストの重複を防ぎ、パフォーマンスを向上

例えば：
同じコンポーネントツリー内で同じデータを複数回フェッチする場合、実際のネットワークリクエストは1回だけ行われます。これにより、特に複雑なコンポーネント構成を持つアプリケーションでパフォーマンスが向上します。

### Data Cache（データキャッシュ）

Data Cache は、fetch リクエストの結果をサーバー上にキャッシュする仕組みです。
Request Memoization とは異なり、レンダリングサイクルを超えて永続化されます。

- デフォルトで有効（特に fetch() を使用する場合）
- ファイルシステムベースのキャッシュストレージ
- キャッシュキーはURL、オプション、ヘッダーに基づいて生成

```mermaid
flowchart TD
    A[fetch リクエスト] --> B{cache オプション}
    B -->|'force-cache'| C[Data Cache に保存]
    B -->|'no-store'| D[キャッシュなし]
    B -->|未指定| C

    A --> E{next.revalidate オプション}
    E -->|設定あり| F[時間ベースの再検証]
    E -->|未設定| G[永続的キャッシュ]

    A --> H{POST リクエスト}
    H -->|Yes| I[デフォルトで no-store]
    H -->|No| J[デフォルトで force-cache]

    C --> K[静的レンダリングが可能]
    D --> L[動的レンダリングに強制]
```

### Full Route Cache（フルルートキャッシュ）

Full Route Cache は、静的にレンダリングされたルートの HTML と RSC（React Server Component）ペイロードをキャッシュします。従来の Static Site Generation (SSG) に相当します。

- ビルド時または初回リクエスト時に生成されるキャッシュ
- デフォルトで静的ルートに対して有効
- 動的ルートではキャッシュされない

### Router Cache（ルーターキャッシュ）

Router Cache は、クライアントサイドのブラウザメモリ内に保持される一時的なキャッシュです。ユーザーがアプリケーション内を移動する際の体験を向上させます。

- クライアントサイドのみで機能
- ナビゲーション中のルート間でデータを共有
- セッション中のみ有効（ページのリロード時にクリア）
- プリフェッチされたルートも含む

e.g.

1. ユーザーが製品リストページから製品詳細ページに移動
2. 詳細ページが Router Cache に保存される
3. ユーザーが製品リストに戻り、再び同じ製品詳細を開く
4. キャッシュから即座に表示（サーバーリクエストなし）

シーケンス図を使って、ユーザーのナビゲーションとRouter Cacheの相互作用を時系列で示しています。
prefetch、ハード更新、router.refresh()などの動作の違いを表現しています。

```mermaid
sequenceDiagram
    participant U as ユーザー
    participant RC as Router Cache
    participant S as サーバー

    U->>RC: ページA訪問
    RC->>S: 初回リクエスト
    S-->>RC: RSCペイロード/HTML返却
    RC-->>U: ページ表示

    U->>RC: ページB訪問 (prefetchあり)
    RC->>S: バックグラウンドでprefetch
    S-->>RC: RSCペイロード保存

    U->>RC: ページBに戻る
    RC-->>U: キャッシュから即時表示

    U->>RC: ハード更新
    RC->>S: 全キャッシュ破棄
    S-->>RC: 新規データ取得
    RC-->>U: 更新されたページ表示

    Note over RC: router.refresh()でソフト更新
    U->>RC: router.refresh()
    RC->>S: 現在のルートのみ再取得
    S-->>RC: 更新データのみ取得
    RC-->>U: 動的部分のみ更新
```

### キャッシングレイヤーの連携

これら4つのレイヤーは以下のように連携します。

1. ユーザーがページにアクセスすると、まず Router Cache をチェック
2. キャッシュにない場合、サーバーでの処理が開始
3. サーバーでは、まず Full Route Cache をチェック
4. ルート生成中に必要なデータは Data Cache から取得
5. 同一レンダリングサイクル内での重複リクエストは Request Memoization で最適化

```mermaid
flowchart TD
    subgraph "Next.js App Router キャッシングレイヤー"
        A[リクエスト] --> B[Router Cache]
        B --> C{キャッシュヒット?}
        C -->|Yes| D[キャッシュされた結果を返す]
        C -->|No| E[Full Route Cache]
        E --> F{キャッシュヒット?}
        F -->|Yes| G[キャッシュされたルート結果を返す]
        F -->|No| H[ルートのレンダリング]
        H --> I[データフェッチ]
        I --> J[Request Memoization]
        J --> K{同一リクエスト?}
        K -->|Yes| L[メモ化された結果を返す]
        K -->|No| M[Data Cache]
        M --> N{キャッシュヒット?}
        N -->|Yes| O[キャッシュされたデータを返す]
        N -->|No| P[データフェッチの実行]
        P --> Q[結果をキャッシュ]
        Q --> R[レンダリング完了]
        R --> S[ルートをキャッシュ]
        S --> D
    end
```

## 5. キャッシュの無効化とリバリデーション (8分)

キャッシュの利点を活かしながら、データの鮮度を保つためには、適切なタイミングでキャッシュを無効化（再検証）する必要があります。Next.js App Router では、主に2つの再検証方法が提供されています。

- 時間ベースの再検証 (Time-based Revalidation)
- オンデマンド再検証 (On-demand Revalidation)

### 時間ベースの再検証 (Time-based Revalidation)

時間ベースの再検証は、指定した時間間隔でキャッシュを自動的に更新する方法です。

- 設定が簡単で自動的に動作する
- トラフィックに関係なく定期的に更新される
- キャッシュの有効期限が切れると、次のリクエストで新しいデータが取得される
- その間、古いキャッシュが提供され続ける（バックグラウンドで再検証）

### オンデマンド再検証 (On-demand Revalidation)

オンデマンド再検証は、特定のイベント（例：CMS でのコンテンツ更新）が発生したときに、プログラムでキャッシュを無効化する方法です。
2種類のメソッドを用いて実行可能です。

- revalidatePath ( パスによる再検証 )
- revalidateTag ( タグによる再検証 )

また、Server Actions 内でもこの2つのメソッドを用いて直接再検証が可能です。

### 図解

```mermaid
flowchart LR
    subgraph "時間ベースの再検証"
        A[fetch with revalidate] --> B[指定時間後に自動的に再検証]
        C[ルートセグメントの設定] --> D[segment config で revalidate 設定]
    end

    subgraph "オンデマンド再検証"
        E[タグベース] --> F["revalidateTag('tag-name')"]
        G[パスベース] --> H["revalidatePath('/path')"]
    end

    subgraph "キャッシュクリア"
        I[Server Action] --> J["unstable_cache() インバリデーション"]
        K[Route Handler] --> L["cookies() または headers() 使用"]
        M[動的関数] --> N["searchParams, cookies, headers の使用"]
    end

    O[キャッシュされたコンテンツ] --> A
    O --> C
    O --> E
    O --> G
    O --> I
    O --> K
    O --> M
```

### キャッシュのクリア方法

#### 開発中にキャッシュをクリアする方法

- 開発サーバーの再起動
- Router Cache のクリア：ブラウザでページをハード更新（Ctrl+F5 または Cmd+Shift+R）
- Data Cache のクリア：.next/cache ディレクトリを削除

#### 本番環境でのキャッシュクリア

- デプロイメントの再実行：Vercel などのホスティングプラットフォームで新しいデプロイメントをトリガー
- API ルートを使用：前述の revalidatePath または revalidateTag を使用する API エンドポイントを呼び出す

## 6. キャッシュ戦略とベストプラクティス

### キャッシュを活用すべき場合

1. 静的コンテンツ
   ブログ記事、製品説明、会社情報など、頻繁に変更されないコンテンツは積極的にキャッシュすべきです。
2. 頻度の低い更新データ
   毎日更新される価格情報や在庫数など、更新頻度が予測可能なデータは、時間ベースの再検証が適しています。
3. 共有データ
   多くのページで使用される共通データ（カテゴリリスト、グローバル設定など）は、タグベースの再検証を使用すると効率的です。

### キャッシュを避けるべき場合

1. パーソナライズされたコンテンツ
   ユーザー固有のデータ（プロフィール情報、ダッシュボード）はキャッシュすべきではありません。
2. リアルタイムデータ
   株価、スポーツスコア、ライブチャットなど、常に最新であるべきデータ。
3. 頻繁に更新されるデータ
   数分ごとに変更される可能性があるデータには、キャッシュを避けるか、非常に短い再検証期間を設定します。
   効果的なキャッシュ戦略の立て方

### 静的レンダリングと動的レンダリングの比較

```mermaid
graph TD
    subgraph "静的レンダリング"
        A[ビルド時にレンダリング] --> B[データはキャッシュされる]
        B --> C[Full Route Cache に保存]
        C --> D[高速なユーザー体験]
        D --> E[低サーバー負荷]
    end

    subgraph "動的レンダリング"
        F[リクエスト時にレンダリング] --> G[データはキャッシュされない]
        G --> H[リクエストごとに新鮮なデータ]
        H --> I[ユーザー固有のコンテンツ]
        I --> J[より高いサーバー負荷]
    end

    K[ルートデータ要件] --> A
    K --> F

    L{動的関数の使用} -->|Yes| F
    L -->|No| A

    M{fetch with no-store} -->|Yes| F
    M -->|No| A

    N{動的なSegment Config} -->|Yes| F
    N -->|No| A
```

### キャッシュ戦略の決定フロー

プロジェクトのデータ要件に基づいて、適切なキャッシュ戦略を選択するための意思決定フローを示しています。
静的vs動的、再検証頻度、ユーザー固有データの必要性などの条件分岐を含みます。

```mermaid
flowchart TD
    A[データ要件分析] --> B{データは頻繁に変更する?}
    B -->|Yes| C[動的レンダリング検討]
    B -->|No| D[静的レンダリング検討]

    C --> E{ユーザー固有のデータが必要?}
    E -->|Yes| F[no-store オプション使用]
    E -->|No| G{一部だけ動的?}
    G -->|Yes| H[静的部分と動的部分の分離]
    G -->|No| F

    D --> I{定期的な更新が必要?}
    I -->|Yes| J[時間ベース再検証]
    I -->|No| K[完全静的キャッシュ]

    J --> L{更新頻度は?}
    L -->|高頻度| M[短い再検証時間]
    L -->|低頻度| N[長い再検証時間]

    K --> O{特定イベントで更新?}
    O -->|Yes| P[オンデマンド再検証]
    O -->|No| Q[ビルド時のみ更新]

    H --> R[Suspenseと組み合わせ]
    F --> S[パフォーマンス最適化検討]

    M --> T[サーバー負荷考慮]
    N --> T
    P --> U[タグベース設計]
    Q --> V[ISRパターン活用]

    R --> W[効率的なUX]
    S --> W
    T --> W
    U --> W
    V --> W
```
